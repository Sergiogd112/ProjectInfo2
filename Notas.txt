-------------------------
DEBUGAR
- Paso a paso por instrucciones (F11). Entramos dentro de una parte del código. 
* podemos ver cómo funciona el código de una función del mismo. Podemos acceder a otras partes.
* podemos ir línea a línea una vez accedido al código. 
	

- Paso a paso por procedimientos (F10). Ejecutamos linea a linea.
	1. Aparece flecha amarilla y botonera superior
	2. nos ejecuta linea a linea todo lo que ocurre
	*podemos ver el valor de cualquier variable en todo momento en la caja de info inferior

En el caso de estar interesadx en una parte del código concreta, en una linea, utilizamos 'breakpoint'.
	1. Click derecho sobre linea
	2. punto de interrupcion
	3. sin ir paso a paso: clicamos a 'iniciar'. Ejecuta directamente hasta ese punto
		3.1. ahora decidimos cómo queremos debugar hasta ese punto sin tener que ejecturar lentamente el codigo superior

ERRORES EN LOS DATOS DE ENTRADA
* cuando es en tiempo de ejecución: el programa está bien escrito, debe haber otro error 
* cuando hay error de tipado y no queremos que pete el programa:
	- SOLUCIÓN: TRY-CATCH
	1. Try: código a analizar
	2. Qué hay que hacer si se detecta un error de excepción

	try
	{
	}
	catch(FormatException)
	{
	Console.WriteLine()
	}


BUCLE DE SIMULACION. Ciclos y tiempo
* queremos hacer un bucle que ejecute una función reiteradas veces. 
- while 


FORMATEO DEL TEXTO. Facilitar legibilidad de texto. 
* magnitudes resultantes pueden tener decimales infinitos. Esto en la vida real no es práctico. Damos decimales finitos
Console.WriteLine("...{0:(type)(cantindad)}",(...));
pe: Console.WriteLine("Velocidad {0:F2}, a.GetVelocidad()");

Es decir, entre corchetes indicamos con la primera cifra un argumento indicada en esa misma posicion, siguiendo el orden marcado, y tras los dos puntos, indicamos con una letra el tipado del argumento y con el valor posteriori la cantidad de decimales deseados

==> cuando queremos implementar un nuevo método a un programa, debemos preguntarnos en qué clase añadirlo


CUANDO CREAMOS UN OBJETO DEL TIPO LISTA DESDE CONSOLA, DONDE ASIGNAMOS UNA VARIABLE (introducida por consola) A CADA PARAMETRO DEL CONSTRUCTOR, ESTA VARIABLE DEJA DE SER ACCESIBLE. 
*PARA ACCEDER A LA INFORMACION, LO HACEMOS MEDIANTE LA POSICION DEL VECTOR
*PARA CREAR UN NUEVO OBJETO, PODEMOS SERGUIR UTILIZANDO LA VARIABLE SIN QUE SE ACTUALICE EL ANTERIOR OBJETO PORQUE SU PARAMETRIZACIÓN YA HA SIDO ASIGNADA.



-----------------------------
PROYECTO 0 - PARTE 1
-----------------------------

******
Fase 1: Añadir los siguientes métodos a la clase FlightPlan

	1. Realiza un cambio en los nombres de los proyectos y de la solución de forma que sean
	auto explicativos.
	2. Añade un Constructor para inicializar todos los atributos de la clase FlightPlan
	3. Añade todos los Gets y Sets para leer valores de los atributos y modificar los valores de
	los atributos.
	4. Añade el método public Boolean HasArrived(): Este método devuelve true si el avión ha
	llegado a su destino y false en caso contrario.
	5. Para realizar el método anterior necesitamos añadir la posición actual, por tanto,
	necesitas modifica el método public void Move (double time)
	6. Añade el método public void Restart(): Este método mueve el avión a las posición inicial.
	7. public double Distance (FlightPlan plan): Este método devuelve la distancia con el plan
	de vuelo recibido como argumento.
******

******
Fase 2: Crear un proyecto Windows Forms y añadir una opción para introducir
datos
	1. Crear un proyecto Windows Forms y añadir un menú de opciones.
	2. Incorporar una primera opción que abra un nuevo formulario en el que introducir los
	datos de los dos planes de vuelo implicados, verificando que no hay errores en los datos
	de entrada. Naturalmente, los datos se cargarán en dos objetos de la clase FlightPlan.
	3. Incorporar una segunda opción al menu que abra un nuevo formulario para introducir
	la distancia de seguridad y el tiempo de ciclo, verificando que no hay errores en los datos
	de entrada.
******


******
Fase 3: Añadir una opción para iniciar la simulación
	1. Añadir una tercera opción al menú que abra un formulario en el que se muestre
	el espacio aéreo y la ubicación inicial de los dos vuelos.
******


******
Fase 4: Mover los aviones
1. Añadir al formulario de simulación un botón que hace que los dos aviones se muevan
un ciclo.
******


******
Fase 5: Ver información de los aviones
	1. Añadir el código necesario para que al clicar el usuario sobre uno de los aviones se
	abra un formulario que muestre la información de ese avión.
******


******
Fase 6: Añadir una línea para mostrar la trayectoria
	1. Añadir el código necesario para mostrar una línea del origen al destino del plan de
	vuelo y comprueba que los aviones se mueves a través de dicha trayectoria
******


******
Fase 7: Mostrar la distancia de seguridad de cada avión
	1. Añadir el código necesario para dibujar una elipse alrededor de cada avión mostrando
	el tamaño de la distancia de seguridad. El avión se debe situar en el centro de la elipse
	cuando realizamos el movimiento a lo largo de la trayectoria.
******


--------------------------------
Nota importante: Para realizar estas fases puede ser de utilidad volver a ver los videos de la semana 3
del curso titulados: Windows Forms Videos.

******
Videos de Soporte de otros años
******
Nota importante: Hace unos años que este ejercicio recibía el nombre de ejercicio de integración y tenía una serie
de video de soporte. En ese ejercicio se trabajaban conceptos diferentes y por tanto ya no aplican a las versiones
actuales del proyecto. Para alguna de las fases de ese proyecto se aportaba un video de apoyo en el que se realizaba
una tarea similar, pero para un proyecto diferente. Era necesario extraer lo relevante del video y adaptarlo al caso
del proyecto que nos ocupa. Os dejamos lo links a dichos video por si queréis echar una ojeada, pero tal y como
hemos comentado son video obsoletos y que se deben tener en cuenta para el proyecto actual.

										Videos de apoyo Fase 2:
										http://youtu.be/eC5eXjJ0Kw8
										http://youtu.be/Y2u9JIJZadQ
										Videos de apoyo Fase 3:
										http://youtu.be/vhGsjtx_dSQ
										http://youtu.be/y01nGA7-J18
										Videos de apoyo Fase 4:
										http://youtu.be/XrMgvEarPTA
										Videos de apoyo Fase 5:
										http://youtu.be/iaQdOIHbFxA

----------------------------


FASE 1
Fase 8: Añadir un botón para realizar la simulación automática
1. Incorporar al formulario de simulación los botones y código necesarios para poder realizar una simulación automática (iniciar y detener simulación automática).

Fase 9: Mostrar datos y distancias de los vuelos
1. Incorporar al formulario de simulación un nuevo botón que al ser clicado muestra un formulario con un DataGridView que muestra los datos de los dos vuelos.
2. Añadir el código necesario para que al clicar sobre la fila correspondiente a un vuelo se abra un nuevo formulario que muestre la distancia entre ese vuelo y el otro.


		ATENCIÓN: Puesto que de momento sólo se trabaja con dos vuelos, esta fase podría implementarse sin utilizar un DataGridView, 
		de forma incluso más simple que la indicada. Sin embargo, en el momento en que pasemos a la versión 2 (con múltiples planes de vuelo) 
		será necesario usar un DataGridView.


Fase 10: Alarma de perdida de separación entre vuelos
1. Añadir el código necesario para informar al usuario, durante la simulación, del momento en el que los vuelos están a una distancia inferior a la de seguridad.
2. Añadir al formulario un botón que al clicar en él se informará al usuario de si los vuelos entrarán en conflicto o no.


Fase 11: Resolución automática de conflicto
1. Añadir el código necesario para que, antes de iniciar la simulación, compruebe si los vuelos entrarán en conflicto y 
pregunte al usuario si quieres resolver el conflicto. En el caso que el usuario responda de forma afirmativa el programa debe 
cambiar automáticamente la velocidad de uno de los vuelos para evitar el conflicto, y proceder a simular con la nueva velocidad. 
En el caso que el usuario responda de forma negativa la simulación continuará de forma habitual.



----------
BLO4. BASE DE DTOS
El programa debe salvar en el fichero de texto los datos como han quedado tras la sesión de trabajo. 
Las bases de datos facilitan el trabajo con datos externos (sobretodo cuando son muchos y variados).
BASE DE DATOS: Fichero con datos + sistema de gestión que permite realizar operaciones
Las operaciones ya están implementadas en la base de datos: solo deben especificarse. 

Debemos ser capaces de:
1. crear base de datos usando SQLite
2. Construir consultas básicas en el lenguaje SQL: buscar, modificar datos
3. usar base en el programa


CREACIÓN DE BASE DE DATOS
SQLite: sistema de gestión contenido en librería C --> libreria proporciona gestor compatible con el lenguaje SQL (no necesita servidor ni configuración, base de datos basada en fichero de texto de hasta 2TB)
	-- Se trata de un proyecto de código libre
	-- base de datos ideal para pequeñas apps
	-- no sigue modelo cliente-servidor
	-- necesitamos programa que nos permita gestionar la base de datos: utilizar el ejecutable de línea de comandos: sqlite3
		-- solo hace falta copiarlo en el disco duro


* El comando SELECT es al igual que CREATE, una función con la que formamos una sentencia SQL
	-- Al escribir una sentencia, esta debe acabar siempre con ; 
	-- los comandos que empiezan con . son propios del gestor y no terminan con ;

	lista de comandos:

	- .\(ejecutable) (nombre fichero a crear) -- este comando crea un fichero que contiene la base de datos en determinada carpeta previamente indicada
	- .schema (nombre tabla) -- comando para ver la descripcion de la tabla creada
	- .quit -- comando para abandonar lenguaje sqlite
	- .tables -- comando que muestra todas las tablas de la base de datos
	- .restore DB_FILE -- comando que carga la base de datos especificada por el fichero DB_FILE
	- .backup DB_FILE -- comando que guarda la base con la que estamos trabajando en un fichero de nombre DB_FILE
	- .help -- permite consultar comandos
	lista sentencias
	- CREATE TABLE (nombre) (nombre1 tipado)
		-- para el tipado: 
			varchar para texto
			primarkey indica al gestor que la columna es la clave (valores unicados, indexa)
	- INSERT INTO (nombre tabla) VALUES (' ');
	- SELECT * FROM (nombre tabla);		-- consultar datos de tabla


	Structured Query Languange SQL
	Lenguaje de programación de alto nivel para acceder a los datos almacenados
	
	
	Lenguaje de Manimulación de Datos DML
	3 instrucciones:
	- INSERT -- añade nuevos registros a una tabla
	- UPDATE -- modifica valores de los atributos de los registros ya almacenados
	- DELETE -- elimina registros
	
	Lenguaje de definición de datos DDL
	Parte de SQL que se utiliza para crear una base de datos y modifica la estructura. 
	3 declaraciones:
	- CREATE -- crea una nueva tabla
	- ALTER -- modifica la estructura de la tabla existente
	- DROP -- borra una tabla existente


	COMANDOS
	- SELECT: Realiza búsquedas y recuperaciones. Devuelve todos los datos almacenados.
		-- para acceder a ciertos campos de entrada:
		SELECT (nombre1, nombre2) FROM (nombre tabla);
			-- para limitar a un subconunto de entradas para que sean coincidentes: WHERE
			-- para ordenar los resultados devueltos: ORDER BY (ASC si ascendiente, DESC si descendiente)
			SELECT * FROM (nombre tabla) WHERE (nombre 1 condicion 1) AND (nombre 1 condicion 2) ORDER BY (nombre1) ASC;
			-- para retornar la cantidad de elementos en la tabla:
			SELECT count(*) FROM (nombre tabla);
			-- para retornar el maximo valor de un campo:
			SELECT max(nombre1) FROM (nombre tabla);

Para poder utilizar una base de datos desde un lenguaje de programacion necesitamos un driver. 
Función del driver: ofrece interfaz de comunicación común entre las clases del lenguaje de programación ppara el acceso y los diferentes gestores 
	- con la misma API (interfaz de programación de apps) el programa pueda utilizar cualquier base de datos. 
	- el driver no viene por defecto con la interfaz .net

	PREPARAR UNA CLASE PARA OPERAR CON LA BASE DE DATOS
	El programa debe tener una clase en la que programar las consultas
		-- cada consulta será un método
		-- debemos añadir a la clase 2 nuevos 'using': using System.Data y System.Data.SQLite
		-- añadir conector cnx 
		-- necesitamos un método que será el ejecutado para abrir la base de datos


		La sentencia int (nombre)=(nombre command).ExecuteNonQuery() nos devuelve el nombre de filas modificadas